<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/mye785c83.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="/mye785c83.github.io/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2021-07-20T16:31:28+09:00</updated><id>/mye785c83.github.io/feed.xml</id><title type="html">mye785C83</title><author><name>mye785C83</name></author><entry><title type="html">proposed Scheme 4차</title><link href="/mye785c83.github.io/posts/proposed04/" rel="alternate" type="text/html" title="proposed Scheme 4차" /><published>2021-07-13T00:00:00+09:00</published><updated>2021-07-13T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/proposed04</id><content type="html" xml:base="/mye785c83.github.io/posts/proposed04/">&lt;h4 id=&quot;biased-deployment&quot;&gt;biased deployment&lt;/h4&gt;

&lt;h4 id=&quot;distance에-따른-channel-할당-및-channel-bandwidth-설정&quot;&gt;distance에 따른 channel 할당 및 channel bandwidth 설정&lt;/h4&gt;

&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;time 설정
    &lt;ul&gt;
      &lt;li&gt;3차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="python" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">biased deployment</summary></entry><entry><title type="html">EC2 보안강화하기</title><link href="/mye785c83.github.io/posts/EC2_security/" rel="alternate" type="text/html" title="EC2 보안강화하기" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/EC2_security</id><content type="html" xml:base="/mye785c83.github.io/posts/EC2_security/">&lt;h5 id=&quot;참고사이트&quot;&gt;참고사이트&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lesstif.com/security/fail2ban-ssh-43843899.html&quot;&gt;fail2ban 으로 SSH 서버 강화하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ec2-인스턴스-설정&quot;&gt;EC2 인스턴스 설정&lt;/h2&gt;

&lt;h4 id=&quot;ssh-port-변경&quot;&gt;SSH port 변경&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; 일단 보류 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;기본 SSH 포트는 22인데 이를 다른 포트로 변경해주는 것이 좋다.&lt;/p&gt;

&lt;h4 id=&quot;password-authentication-for-ssh&quot;&gt;password authentication for SSH&lt;/h4&gt;

&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; 일단 보류: 굳이 밖에서 서버 접속할 일 없음 &lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo passwd `username`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;EC2의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username=ubuntu&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;sshd_conf-file-업데이트&quot;&gt;sshd_conf file 업데이트&lt;/h5&gt;

&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; 일단 보류 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ssh/sshd_config&lt;/code&gt; 파일을 열어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordAuthentication&lt;/code&gt; 값을 yes로 변경한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /etc/ssh/sshd_config

PasswordAuthentication yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ssh-재시작&quot;&gt;SSH 재시작&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; 일단 보류 &lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;fail2ban-설정&quot;&gt;fail2ban 설정&lt;/h2&gt;

&lt;h4 id=&quot;fail2ban의-역할&quot;&gt;fail2ban의 역할&lt;/h4&gt;</content><author><name>mye785C83</name></author><category term="Web" /><category term="AWS" /><category term="EC2" /><summary type="html">참고사이트 fail2ban 으로 SSH 서버 강화하기</summary></entry><entry><title type="html">background 개념</title><link href="/mye785c83.github.io/posts/background/" rel="alternate" type="text/html" title="background 개념" /><published>2021-07-12T00:00:00+09:00</published><updated>2021-07-12T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/background</id><content type="html" xml:base="/mye785c83.github.io/posts/background/">&lt;h2 id=&quot;fading&quot;&gt;fading&lt;/h2&gt;

&lt;h4 id=&quot;type에-따른-fading-분류&quot;&gt;type에 따른 fading 분류&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ktword.co.kr/abbr_view.php?m_temp1=641&quot;&gt;Fading - 정보통신기술용어해설&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;csmaca&quot;&gt;CSMA/CA&lt;/h2&gt;

&lt;h4 id=&quot;하나의-ap-or-mobile-station이-destination이-생겼을-경우&quot;&gt;하나의 AP (or mobile station)이 destination이 생겼을 경우&lt;/h4&gt;

&lt;h4 id=&quot;downlink-하나의-channel에-대해&quot;&gt;(downlink): 하나의 channel에 대해&lt;/h4&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">fading</summary></entry><entry><title type="html">proposed Scheme 3차</title><link href="/mye785c83.github.io/posts/proposed03/" rel="alternate" type="text/html" title="proposed Scheme 3차" /><published>2021-07-06T00:00:00+09:00</published><updated>2021-07-06T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/proposed03</id><content type="html" xml:base="/mye785c83.github.io/posts/proposed03/">&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;time 설정
    &lt;ul&gt;
      &lt;li&gt;simulator에서 한번의 t에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOT_PER_TX&lt;/code&gt;만큼의 시뮬레이션이 일어난다.&lt;/li&gt;
      &lt;li&gt;전체 시뮬레이션 시간은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_end_time*TIMESLOT_PER_TX&lt;/code&gt;인 셈이다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;channel에 할당된 node 개수에 비례하게 결정된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 만큼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_end_time&lt;/code&gt; 을 변경한다.&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;n&quot;&gt;ch_end_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param_end_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch_weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOT_PER_TX&lt;/code&gt; 동안 destination이 있는 AP는 한 번의 packet만 전송할 가능성이 있고 기존의 시뮬레이션 코드에서 각 node의 throughput을 구할 때 전송에 성공한 packet에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_end_time&lt;/code&gt; 을 단위로 하여 throughput을 구했다.&lt;/li&gt;
      &lt;li&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 만큼 늘어난 end time에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 만큼 timeslot을 줄임으로서 결론적으로 모든 채널이 같은 시간동안 시뮬레이션을 한 것같은 환경을 구현한다.&lt;/li&gt;
      &lt;li&gt;한 번의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOT_PER_TX&lt;/code&gt; 동안 packet이 전송완료되므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 만큼 줄어든 timeslot은 bandwidth가 큰 채널의 경우 전송이 빨리 완료되는 것과 같은 효과를 낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;시뮬레이션-결과&quot;&gt;시뮬레이션 결과&lt;/h2&gt;

&lt;h4 id=&quot;시뮬레이션-환경&quot;&gt;시뮬레이션 환경&lt;/h4&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;	          &lt;span class=&quot;c1&quot;&gt;# grid g x g
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;# area size
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;# number of nodes
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;# number of channels
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;82&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;# carrier sense threshold
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# simulation end time
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;# CST margin
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;시뮬레이션-결과-1&quot;&gt;시뮬레이션 결과&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/20_total_tput.png&quot; alt=&quot;throughput graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빨간색의 경우 distance에 따라 node를 균등하게 분배하고 돌린 시뮬레이션(type2)의 결과이고 초록색의 경우 distance의 range를 정해서 비슷한 distance끼리 묶어 node 개수에 비례하게 bandwidth를 설정하고 돌린 시뮬레이션(type3)의 결과이다.&lt;/p&gt;

&lt;p&gt;예상한 결과와 다르게 bandwidth를 설정해도 thoroughput의 향상을 확인할 수 없었다.&lt;/p&gt;

&lt;h4 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h4&gt;
&lt;p&gt;시뮬레이션에서 node 200개는 각 채널에 21, 49, 115, 15 로 분배되었는데 type2 시뮬레이션과 각 채널의 전송에 성공한 packet의 비율을 비교해봤을 때 115개의 노드가 할당된 channel의 경우 성공률이 너무 떨어진 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;실제 네트워크 환경에서 노드가 100개 넘게 할당되는 경우는 너무 드물고 한 채널에 너무 많은 채널이 할당됨으로 인한 collision 증가로 throughput이 증가하지 않고 오히려 감소한 것 같다.&lt;/p&gt;

&lt;h4 id=&quot;대안&quot;&gt;대안&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;biased deployment 코드 수정
    &lt;ul&gt;
      &lt;li&gt;처음 새로운 proposed scheme을 구상할 때 단순히 distance 순서로만 할 경우, 한 채널에서 node끼리 심한 distance 차이를 보일 경우 생길 edge 현상을 해결하기 위해 bandwidth를 설정하자고 생각했는데 시뮬레이터에서 node들 간에 distance차는 연속적으로 증가하기 때문에 type2 시뮬레이션을 돌릴 때 channel에 할당된 node들 사이에 distance차가 심하게 발생하도록 biased deployment를 수정하고자 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 채널에 node가 너무 쏠리는 경우에 어떻게 할 것인지
    &lt;ul&gt;
      &lt;li&gt;위의 예시 결과처럼 한 채널에 전체 node의 절반 이상이 쏠리거나 node가 200개만큼 증가하는 등 bandwidth에 의한 이익보다 collision에 의한 손실이 커지는 것을 방지하기 위해 어느 정도 node 할당을 조절해야 할 것 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="python" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정</summary></entry><entry><title type="html">AWS EC2에서 Express.js 서버 배포 및 MongoDB 설정</title><link href="/mye785c83.github.io/posts/EC2_MEN_deploy/" rel="alternate" type="text/html" title="AWS EC2에서 Express.js 서버 배포 및 MongoDB 설정" /><published>2021-07-02T00:00:00+09:00</published><updated>2021-07-02T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/EC2_MEN_deploy</id><content type="html" xml:base="/mye785c83.github.io/posts/EC2_MEN_deploy/">&lt;h5 id=&quot;참고-사이트&quot;&gt;참고 사이트&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://chinmaypatil.medium.com/deploying-nodejs-express-mongodb-application-on-aws-ec2-e32a8e3ea8a1&quot;&gt;Deploying NodeJS, Express, MongoDB application on AWS EC2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;expressjs-mongodb-환경설정&quot;&gt;Express.js, MongoDB 환경설정&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;node-npm-설치&quot;&gt;node, npm 설치&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install nodejs
sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 npm version이 있다면&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install npm@[version] -g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mongodb-설치&quot;&gt;MongoDB 설치&lt;/h4&gt;
&lt;p&gt;다음 &lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/&quot;&gt;docs&lt;/a&gt;를 따라하면 어렵지 않게 설치후 실행가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl status mongod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 통해 MongoDB가 잘 실행되는 것을 확인했으면 DataBase 보안을 위해 authorization을 추가해야한다.&lt;/p&gt;

&lt;h2 id=&quot;database-설정&quot;&gt;DataBase 설정&lt;/h2&gt;

&lt;h4 id=&quot;admin-database-실행-후-root-관리자-생성&quot;&gt;admin database 실행 후, root 관리자 생성&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; use admin
&amp;gt; db.createUser({ user: '이름', pwd: '비밀번호', roles: ['root']})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mongodconf에서-authorization을-enabled로-설정&quot;&gt;mongod.conf에서 authorization을 enabled로 설정&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mongod.conf

net:
  port: 27017
  bindIp: 0.0.0.0

# ...

security:
  authorization: 'enabled'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;warning&quot;&gt;이때 들여쓰기 2칸 제대로 안했다가 conf error 난…&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;mongod-service-재실행&quot;&gt;mongod service ‘재실행’&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service mongod restart
sudo systemctl status mongod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서버의-mongo-uri에-해당하는-database-및-user-pwd-생성&quot;&gt;서버의 MONGO URI에 해당하는 database 및 user, pwd 생성&lt;/h4&gt;

&lt;p&gt;&lt;span class=&quot;warning&quot;&gt;MONGO URI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env&lt;/code&gt; 파일에 설정되어 있다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;나의 경우 admin database로 가 server database owner에 대한 role도 root user에 추가해주었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; db.updateUser(&quot;username&quot;, {roles:[{role: 'dbOwner', db: 'database name'}]})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;생성한-user-정보로-server-database-접속해보기&quot;&gt;생성한 user 정보로 server database 접속해보기&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongo --port 27017 -u 사용자계정 -p '비밀번호' --authenticationDatabase '디비이름'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 database 설정까지 완료했으면 이제 Express.js 서버를 가져와 실행해준다. (database를 미리 한 이유는 안하면 서버를 먼저 가져와서 실행해봤자 database 접속 못 할거라)&lt;/p&gt;

&lt;h2 id=&quot;expressjs-실행&quot;&gt;Express.js 실행&lt;/h2&gt;

&lt;h4 id=&quot;packagejson-설치&quot;&gt;package.json 설치&lt;/h4&gt;
&lt;p&gt;github에 존재하는 Express.js repository를 clone 해온 후 해당 폴더로 이동해 package.json에 해당하는 패키지들을 설치한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지 마치고 나면 해당 폴더의 하위에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules/&lt;/code&gt; 폴더가 생성된 것을 확인할 수 있다.
여기까지 마치면 서버를 실행해 서버가 잘 실행되고 데이터베이스에 잘 연결되었는지 확인한다.&lt;/p&gt;

&lt;p class=&quot;comment-box&quot;&gt;&lt;strong&gt;포트 방화벽 해제&lt;/strong&gt;
외부에서 서버의 특정 포트에 접근하려면 해당 포트의 방화벽을 해제해야 한다. &lt;br /&gt;
&lt;span class=&quot;warning text-highlight&quot;&gt;어떤 포트를 왜 열어야 되는지 정확히 모르겠다&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;nginx-설정&quot;&gt;NGINX 설정&lt;/h2&gt;

&lt;h4 id=&quot;nginx-설치&quot;&gt;nginx 설치&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;nginx&quot;&gt;nginx&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP 프로토콜을 준수하여 HTML, CSS, JavaScript, 이미지와 같은 정적 파일을 웹 브라우저(Chrome, Opera …)에 전송하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;리버스 프록시(Reverse Proxy)로서의 역할
    &lt;ul&gt;
      &lt;li&gt;proxy server는 가상 서버이고 reverse server가 실제 응용프로그램 서버를 의미한다.&lt;/li&gt;
      &lt;li&gt;client가 proxy server로 request를 보내면 proxy server는 reverse server로부터 데이터를 가져오는 역할을 한다.&lt;/li&gt;
      &lt;li&gt;웹 응용 프로그램 서버에 reverse proxy가 필요한 이유는 request에 대한 버퍼링 때문이다. client가 직접 app server에 요청을 보낼 경우, 2개 이상의 요청이 들어올 경우, 처리 중인 request 외에는 응답 대기 상태가 되기 때문에 proxy server를 두어 request를 배분하는 역할을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nginx-configuration-파일-설정&quot;&gt;nginx configuration 파일 설정&lt;/h4&gt;

&lt;p&gt;http/https로 보낸 요청을 실제 서버 port로 pass 해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/nginx/sites-available&lt;/code&gt; 에 존재하는 기존의 default 파일을 삭제 후 http/https로 넘어오는 request를 처리할 server block을 생성한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# default

server {
	listen 443;
	server_name `domain name`; # 여러 개의 도메인을 설정할 경우 space로 구분하면 됨
	location / {
		proxy_pass http://127.0.0.1:`web server port`;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; MongoDB compass로 내 데이터베이스를 좀 더 쉽게 관리하고 싶은데 nginx 설정 후, DATABASE로 접근이 안된다… configuration 설정을 어떻게 해야하는걸까…&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;nginx-실행하기&quot;&gt;nginx 실행하기&lt;/h4&gt;
&lt;p&gt;먼저 configuration file이 제대로 작성되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;제대로 작성되었다면 nginx를 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl enable nginx
sduo systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pm2&quot;&gt;PM2&lt;/h2&gt;

&lt;p class=&quot;comment-box&quot;&gt;원래는 구매한 도메인 SSL certificate 완료를 해서 해당 도메인을 서버에 씌우고 web server의 port를 443으로 변경하여 실행하였다. 근데 PM2에서 해당 서버를 실행하면 &lt;span class=&quot;text-highlight warning&quot;&gt;Error: listen EACCES 0.0.0.0:443&lt;/span&gt; 다음과 같은 error가 떠서 서치해본 결과 pm2에서 http, https 포트로의 실행은 불가능했고 따라서 다시 기존처럼 서버 포트를 설정하고 nginx를 통해 http/https 요청이 서버 port로 넘어갈 수 있게 하고 pm2를 실행하였다.&lt;/p&gt;

&lt;h4 id=&quot;ecosystem-file-생성&quot;&gt;ecosystem file 생성&lt;/h4&gt;

&lt;h4 id=&quot;ecosystem-file-실행&quot;&gt;ecosystem file 실행&lt;/h4&gt;

&lt;h2 id=&quot;cerbot&quot;&gt;cerbot&lt;/h2&gt;
&lt;p&gt;원래는 pm2에서 포트 443을 이용해 https 통신을 할 경우 cerbot을 통해 도메인에 대한 ssl certificate key를 받아 이를 설정하는 것 같은데 key 발급을 위해 http로 도메인에 request를 보내 인증을 진행하는 것 같았다.&lt;/p&gt;

&lt;p&gt;하지만 나의 경우 http로 할 경우 이미 SSL 인증을 받아서 그런지 502 error가 떴고 오히려 443으로 열었을 경우 진행이 잘 되었는데 이렇게 해도 되는지 모르겠으며 왜 되는지도 모르겠다.&lt;/p&gt;</content><author><name>mye785C83</name></author><category term="Web" /><category term="AWS" /><category term="EC2" /><category term="ExpressJS" /><category term="MongoDB" /><category term="NodeJS" /><category term="nginx" /><category term="pm2" /><summary type="html">참고 사이트 Deploying NodeJS, Express, MongoDB application on AWS EC2</summary></entry><entry><title type="html">proposed Scheme 2차</title><link href="/mye785c83.github.io/posts/proposed02/" rel="alternate" type="text/html" title="proposed Scheme 2차" /><published>2021-06-02T00:00:00+09:00</published><updated>2021-06-02T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/proposed02</id><content type="html" xml:base="/mye785c83.github.io/posts/proposed02/">&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeslot_per_tx&lt;/code&gt; 설정
    &lt;ul&gt;
      &lt;li&gt;기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOTS_PER_TX&lt;/code&gt;로 고정되어 있던 time slot 크기를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOTS_PER_TX * ch_weight[ch]&lt;/code&gt;로 변경
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;기대 결과&lt;/p&gt;

            &lt;p&gt;늘어난 timeslot만큼 $\text{tx_packet}$ 의 수가 늘어날 것으로 예상&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;실제 결과&lt;/p&gt;

            &lt;p&gt;실제로 $\text{type2}$와 결과를 비교해보면 $\text{tx_packet}$의 수는 줄어들고, $\text{lost_packet}$의 수는 거의 비슷해 결론적으로 $\text{total throughput}$이 줄어드는 것을 확인할 수 있었다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;결과 분석&lt;/p&gt;

            &lt;p&gt;각 채널에 할당된 cst를 확인해보면 미세하게 $\text{type3}$의 cst가 모두 작은 것을 확인할 수 있다.&lt;/p&gt;

            &lt;p&gt;cst 할당 방법은 가장 멀리 있는 node를 기준으로 설정하는 방법을 택했고 biased deployment 결과 앞쪽 그룹에 node들이 많이 몰려 있기 때문에 각 채널의 가장 멀리 있는 node의 $\text{distance}$ 값이 모두 증가한다. 따라서 cst 값이 작아질 수 밖에 없다.&lt;/p&gt;

            &lt;p&gt;channel 별 throughput을 비교하면 모든 채널의 throughput이 감소하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;가 1 이하인 channel의 경우, timeslot이 감소해서인 것 같다.&lt;/p&gt;

            &lt;p&gt;다만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;가 1보다 큰 경우에도 channel throughput이 감소하는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;에 의해 늘어난 timeslot의 이득보다 node 개수가 많아지면서 증가한 간섭에 의한 손실이 더 커서인 것으로 예상된다.&lt;/p&gt;

            &lt;p class=&quot;edit-box&quot;&gt;&lt;span class=&quot;edit-info&quot;&gt;21.07.20 수정&lt;/span&gt;
  python simulator 상에서 time_slot은 작은 시뮬레이션 과정으로 한 time_slot 안에서 일어난 packet 전송은 그 iteration에서 종료된다는 가정 하에 진행된다. 즉, 한 time_slot동안 contention window 경쟁이 일어나며 time_slot 동안 경쟁에 승리해 전송을 시작한 packet이 완료될 때까지 계속 경쟁이 일어난다는 뜻이다.&lt;br /&gt;
  &lt;br /&gt;
  bandwidth가 커지면 packet 전송 속도가 그만큼 빨라져야 하는데 weight에 비례하게 timeslot을 변경할 경우, bandwidth가 커 timeslot이 증가한 채널은 packet이 전송이 완료되는데 더 오래 걸린다는 뜻이 된다.&lt;br /&gt;
  &lt;br /&gt;
  bandwidth가 커져 packet 전송 속도가 빨라진다는 것은 그만큼 contention window 경쟁 횟수가 증가한다는 것을 의미하기 때문에 한 번의 contention window 경쟁을 나타내는 time_slot의 크기를 bandwidth가 커질 경우 증가시키는 것은 적절하지 않은 설정이었다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;대안&quot;&gt;대안&lt;/h4&gt;
&lt;p&gt;biased deployment 실행시 node가 몰려 있는 distance 범위를 node가 가질 수 있는 distance 범위의 중앙 부분에 올 수 있도록 코드를 변경하였다.&lt;/p&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="python" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정</summary></entry><entry><title type="html">proposed Scheme 1차</title><link href="/mye785c83.github.io/posts/proposed01/" rel="alternate" type="text/html" title="proposed Scheme 1차" /><published>2021-04-29T00:00:00+09:00</published><updated>2021-04-29T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/proposed01</id><content type="html" xml:base="/mye785c83.github.io/posts/proposed01/">&lt;h2 id=&quot;1차&quot;&gt;1차&lt;/h2&gt;

&lt;h3 id=&quot;mobile-node-deployment&quot;&gt;Mobile Node Deployment&lt;/h3&gt;

&lt;h4 id=&quot;biased-deployment&quot;&gt;Biased Deployment&lt;/h4&gt;

&lt;p&gt;AP와 ms 사이의 distance 값이 특정 범위에 몰리도록 mobile node를 분포하는 것&lt;/p&gt;

&lt;p&gt;⇒ high demand node의 발생이 불규칙적이고 예측할 수 없을 때 특정 distance에 demand가 과도하게 발생한다면 논문에서 제시한 방법이 비효율적일 수 있다.&lt;/p&gt;

&lt;p class=&quot;comment-box&quot;&gt;&lt;strong&gt;WHY?&lt;/strong&gt;
한 channel에 할당된 node들 사이에 distance차가 목표한 바와 다르게 커질 수 있기 때문&lt;/p&gt;

&lt;h3 id=&quot;setting-channel-and-cst&quot;&gt;Setting channel and CST&lt;/h3&gt;

&lt;h4 id=&quot;type1-기존-base-simulator-logic&quot;&gt;type1. 기존 base simulator logic&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;mobile node index를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_num_channels&lt;/code&gt; 로 나눈 나머지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_cs_thresh&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_margin&lt;/code&gt; 으로 모든 채널이 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;type2-distance에-따른-node-grouping&quot;&gt;type2. distance에 따른 node grouping&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;각 channel은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(param_num_nodes / param_num_channels)&lt;/code&gt; 만큼의 node를 할당받는다&lt;/li&gt;
      &lt;li&gt;node는 associated AP와의 distance 값이 작은 순서대로 channel index 0부터 차례대로 channel 할당을 받는다
        &lt;ul&gt;
          &lt;li&gt;channel index가 가장 작은 channel( $ch[0]$ )에 할당된 node들의 distance가 가장 작다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;channel에 할당된 node들 중 distance값이 가장 큰 node 기준&lt;/li&gt;
      &lt;li&gt;해당 node가 견딜 수 있는 SNR 크기를 경계로 하여 CST 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;각 node는 associated AP와의 distance가 작은 순서대로 channel index 0부터 차례로 channel 할당을 받는다.&lt;/li&gt;
      &lt;li&gt;channel에 할당된 node의 dist중 가장 작은 dist( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min_dist&lt;/code&gt; )를 기준으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dist_threshold&lt;/code&gt;를 정해 해당 할당 받는 node의 distance가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min_dist + dist_threshold&lt;/code&gt; 보다 클 경우 channel index를 1 늘린다.&lt;/li&gt;
      &lt;li&gt;할당된 node 개수를 비율만큼 channel bandwidth를 할당한다.
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;[simulator 상에서 구현]&lt;/p&gt;

            &lt;p&gt;simulator는 1 time마다 각 channel을 돌면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_vector&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector&lt;/code&gt; 를 구한다.&lt;/p&gt;

            &lt;p&gt;실제로 네트워크 상에서 bandwidth가 커지면 packet 전송 속도가 빨라지기 때문에 1 time당 더 많은 packet이 오갈 수 있다.&lt;/p&gt;

            &lt;p&gt;simulator 상에서는 bandwidth에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector&lt;/code&gt; 에 weight를 주어 속도를 주었다.&lt;/p&gt;

            &lt;p&gt;( » &lt;em&gt;weight: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(param_num_nodes / param_num_channels)&lt;/code&gt; 와의 비율&lt;/em&gt; )&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;channel에 할당된 node들 중 distance값이 가장 큰 node 기준&lt;/li&gt;
      &lt;li&gt;해당 node가 견딜 수 있는 SNR 크기를 경계로 하여 CST 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stat_rx_packets_ms&lt;/code&gt; 카운트
    &lt;ul&gt;
      &lt;li&gt;매 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch&lt;/code&gt;에 따른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector * ch_weight[ch]&lt;/code&gt;를 더함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;random하게 분포된 node에서 $\text{type1}$과 $\text{type2}$의 throughput을 비교해보면 $\text{type2}$가 $1.25$ 배 가량 향상된 것을 확인할 수 있었다.
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;em&gt;실제 논문에서는 2배 가량 차이나는데 어떤 차이일지?&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;skewed deployment에서 $\text{type2}$과 $\text{type3}$의 channel 별 throughput과 전체 throughput을 비교하면
    &lt;ul&gt;
      &lt;li&gt;전체 throughput의 경우 거의 비슷하다(약간의 감소)&lt;/li&gt;
      &lt;li&gt;channel별 throughput을 비교해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 즉, bandwidth에 따라 설정된 $weight$ 가 크면 커지고 작으면 작아진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;2번-결과에-대한-분석&quot;&gt;&amp;lt;2번 결과에 대한 분석&amp;gt;&lt;/h5&gt;

&lt;p&gt;bandwidth가 클수록 그만큼 그 채널에 할당된 node가 많다는 뜻인데 그 채널에 대해서&lt;span style=&quot;color: red;&quot;&gt;‘&lt;strong&gt;만&lt;/strong&gt;’&lt;/span&gt; $weight$에 의해 많은 throughput이 생성된 것처럼 되고 나머지 다른 채널의 경우 모두 $weight$에 의해 throughput이 낮아지기 때문에 $weight$가 큰 채널에 의해 높은 throughput을 가지게된 node와 $weight$가 낮은 채널에 의해 낮은 throupghput을 가지게된 node간의 throughput 상쇄가 일어나 결론적으로는 합이 비슷해지는 것 같다.&lt;/p&gt;

&lt;p class=&quot;edit-box&quot;&gt;&lt;span class=&quot;edit-info&quot;&gt;21.07.20 수정&lt;/span&gt;
bandwidth를 설정할 경우 node 개수를 제외하고는 packet을 전송하고 받는 과정이 동일하기 때문에 bandwidth가 없는 경우와 유사한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_vector == 1&lt;/code&gt; (node 개수에 비례해 약간의 차이는 있을 것) 에 단순히 성공한 packet에 대해 weight만 부여되게 된다. &lt;br /&gt;
&lt;br /&gt;
bandwidth가 작은 채널의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_vector == 1&lt;/code&gt; 가 줄고 그만큼 간섭도 줄 것이기 때문에 단순히 개수에 비례해 throughtput이 감소한다.&lt;br /&gt;
&lt;br /&gt;
하지만 bandwidht가 큰 채널의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_vector == 1&lt;/code&gt;가 증가하지만 그에 비례해 간섭도 증가하기 때문에 전송되는 packet의 개수는 늘지만 그만큼 전송에 실패하는 packet도 많아지기 때문에 채널 throughput이 기대한 만큼의 향상을 보이지 않은 것 같다.&lt;/p&gt;

&lt;h5 id=&quot;2번-결과에-대한-대안&quot;&gt;&amp;lt;2번 결과에 대한 대안&amp;gt;&lt;/h5&gt;

&lt;p&gt;실제로는 bandwidth가 커지면 그만큼 $\text{mbps}$ 가 커져서 한 timeslot에 더 많은 packet이 전송될 수 있다.(수신을 성공하는지와는 관계 없이)
따라서 성공한 packet에 $weight$를 부여하는 대신 timeslot 자체를 $weight$에 따라 조절해 bandwidth가 커 weight가 커지면 timeslot도 커지게 해 비슷한 효과를 내려고 한다.&lt;/p&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="python" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">1차</summary></entry><entry><title type="html">python network simulator 분석</title><link href="/mye785c83.github.io/posts/python_simulator/" rel="alternate" type="text/html" title="python network simulator 분석" /><published>2021-04-28T00:00:00+09:00</published><updated>2021-04-28T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/python_simulator</id><content type="html" xml:base="/mye785c83.github.io/posts/python_simulator/">&lt;h4 id=&quot;variable-setting&quot;&gt;variable setting&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;'''
[input]
----------------------------------------------------------------
NUM_GRID,       grid 개수. NUM_GRID=n에 대해 n*n개의 AP가 생성됨
AREA_SIZE,      한 grid 당 사이즈
NUM_NODES,      mobile node 개수
NUM_CH,         channel 개수
PROTO,          protocol(tramsmission) type 
    0: carriersense
    1: DSC
    2: smart
    3: new carrier
CS,             CST 값 
SEED,           seed 값
END,            simulation end time. END만큼 각 채널이 전송 반복
VERBOSE, 
IDEAL, 
LATEX, 
MARGIN,         cst margin 값 (실제 setting cst = 설정 cst +  margin)
DEPLOY,         mobile node 분포 형태
    0: seed를 이용한 random 분포
    1: AP와 ms 사이의 distance가 특정 범위에 몰리도록 분포
SET_CHANNEL,
    0: 기존의 방식대로
    1: 각 채널이 distance에 따라 같은 개수의 node를 가지도록
    2: 각 채널이 assigned node 개수에 따라 다른 bandwidth를 가지도록
------------------------------------------------------------------
'''&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RunSim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NUM_GRID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_NODES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NODES_PER_CELL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AREA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_CH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEED&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERBOSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CH_BW_LOSS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LATEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDEAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MARGIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TOKEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEPLOY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SET_CHANNEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# variable setting
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;param_seed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEED&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_GRID&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_aps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_nodes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_NODES&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_channels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_CH&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_end_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;END&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_cs_thresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PROTO&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_verbose&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERBOSE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_ch_bw_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CH_BW_LOSS&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_export_latex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LATEX&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_margin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MARGIN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;simulation-logic&quot;&gt;simulation logic&lt;/h2&gt;

&lt;h4 id=&quot;simulation-가정&quot;&gt;simulation 가정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;SNR threshold만 넘으면 패킷이 성공적으로 수신되었다고 가정한다.&lt;/li&gt;
  &lt;li&gt;설정된 END_TIME동안 TIMESLOT_PER_TX 을 주기로 하는 서브 시뮬레이션이 반복된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;channel이 완전히 비어있는 상태에서 서브 시뮬레이션이 시작된다.&lt;/p&gt;

    &lt;p&gt;⇒ 따라서 처음에 destination이 있는 모든 ap가 channel이 idle이라고 감지한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;TIMESLOT_PER_TX 동안 전송이 시작된 packet은 전송 시작된 시점에 상관없이 다음 iteration에서 모두 전송을 완료한다고 가정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;simulation-flowchart&quot;&gt;simulation flowchart&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simulation_flowchart.jpg&quot; alt=&quot;simulation flowchart&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한번의 t iteration에서 각 channel은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time_slot_per_tx&lt;/code&gt; 동안 simulation을 진행한다.&lt;/li&gt;
  &lt;li&gt;destination을 가진 AP들 중 가장 작은 contention window(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;win_count&lt;/code&gt;)를 가진 AP가 packet 전송을 시작한다.
    &lt;ul&gt;
      &lt;li&gt;destination을 가진 AP들은 모두 channel이 idle이라고 판단하고 contention window count를 시작한 것&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;win_count&lt;/code&gt;만큼 모든 AP들이 contention window count를 진행한 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나머지 destiation을 가진 AP들은 carrier sensing을 통해 busy로 감지될 경우 transmission 시도를 pause한다.&lt;/li&gt;
  &lt;li&gt;channel을 idle로 탐지한 AP들의 경우 자신의 남은 contention window에 대해 다시 count를 시작한다.&lt;/li&gt;
  &lt;li&gt;이 중 가장 작은 contension window를 가진 AP가 packet 전송을 시작한다.&lt;/li&gt;
  &lt;li&gt;누적된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;win_count&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slot_count&lt;/code&gt;)가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time_slot_per_tx&lt;/code&gt; 커지거나 더 이상 전송을 시도하는 AP가 없을 경우, 해당 iteration은 종료되고 전송을 시작한 packet들에 대해 SNR을 구해 packet이 성공적으로 도착했는지 판단한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;앞으로-구현해야하는-코드&quot;&gt;앞으로 구현해야하는 코드&lt;/h2&gt;

&lt;h4 id=&quot;biased-deployment-환경-구현&quot;&gt;biased deployment 환경 구현&lt;/h4&gt;

&lt;h4 id=&quot;distance-range-설정&quot;&gt;distance range 설정&lt;/h4&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="python" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">variable setting ```python ‘’’ [input] —————————————————————- NUM_GRID, grid 개수. NUM_GRID=n에 대해 n*n개의 AP가 생성됨 AREA_SIZE, 한 grid 당 사이즈 NUM_NODES, mobile node 개수 NUM_CH, channel 개수 PROTO, protocol(tramsmission) type 0: carriersense 1: DSC 2: smart 3: new carrier CS, CST 값 SEED, seed 값 END, simulation end time. END만큼 각 채널이 전송 반복 VERBOSE, IDEAL, LATEX, MARGIN, cst margin 값 (실제 setting cst = 설정 cst + margin) DEPLOY, mobile node 분포 형태 0: seed를 이용한 random 분포 1: AP와 ms 사이의 distance가 특정 범위에 몰리도록 분포 SET_CHANNEL, 0: 기존의 방식대로 1: 각 채널이 distance에 따라 같은 개수의 node를 가지도록 2: 각 채널이 assigned node 개수에 따라 다른 bandwidth를 가지도록 —————————————————————— ‘’’</summary></entry><entry><title type="html">my proposed Scheme</title><link href="/mye785c83.github.io/posts/proposed_scheme/" rel="alternate" type="text/html" title="my proposed Scheme" /><published>2021-04-21T00:00:00+09:00</published><updated>2021-04-21T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/proposed_scheme</id><content type="html" xml:base="/mye785c83.github.io/posts/proposed_scheme/">&lt;h4 id=&quot;based-paper&quot;&gt;based paper&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.hindawi.com/journals/wcmc/2019/2149606/&quot;&gt;A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;my-proposed-scheme&quot;&gt;my proposed Scheme&lt;/h2&gt;

&lt;p&gt;network density가 높아지고 node의 이동성도 높아지는만큼 특정 distance를 가진 node들에 대한 traffic이 증가하는 traffic pattern이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;기존 base paper처럼 단순히 channel에 distance 순으로 같은 개수만큼 균등하게 node를 분배한다면 위와 같은 상황에서 한 채널을 할당받은 node group안에서 distance 차로 인한 edge node가 발생할 수 있다.&lt;br /&gt;
또한 base paper에서 하나의 node group의 node들 중 가장 거리가 먼 node를 기준으로 CST를 설정하기 때문에 group 안에서 distance 차이가 크게 날 경우 conservative transmission이 심해질 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 distance 순으로 channel을 할당하는 것을 유지하되, distance가 비슷한 node들끼리 경쟁할 수 있도록 node를 grouping한 뒤, node 개수에 비례하게 channel bandwidth를 설정해 node들이 최대한 덜 conservative transmission을 할 수 있게 하면서 또 edge node의 발생을 줄일 수 있도록 한다.&lt;/p&gt;

&lt;h4 id=&quot;my-proposed-scheme에서-발생할-수-있는-문제-상황&quot;&gt;my proposed Scheme에서 발생할 수 있는 문제 상황&lt;/h4&gt;

&lt;p&gt;network 환경이 특정 distance에 집중된 상황에서 bandwidth를 적용해 비슷한 distance끼리 경쟁하게 될 때 특정 distance에 너무 몰려버리면 비슷한 distance끼리 경쟁하게 돼서 얻을 수 있는 이점보다 너무 많은 node로 인해 collision 증가가 심해져 얻게 되는 손해가 더 커질 수 있다. 따라서 이 둘 사이에서 적당한 균형을 찾아야 한다.&lt;/p&gt;

&lt;h2 id=&quot;1차-목표&quot;&gt;1차 목표&lt;/h2&gt;

&lt;p&gt;associated AP와의 distance가 특정 범위에 몰리도록 설정된 환경에서 channel에 균등한 distance range를 설정해 해당 range 안에 들어오는 node를 channel에 할당하는 방식을 취한다.&lt;/p&gt;

&lt;p&gt;이때 channel에 할당된 node 개수에 비례하게 bandwidth를 설정해 node 개수가 많은 channel의 경우 bandwidth가 그만큼 커져 더 많은 packet이 전송될 수 있도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;최종-목표&quot;&gt;최종 목표&lt;/h2&gt;

&lt;p&gt;bandwidth가 넓어지면서 얻는 troughput 이득과 node 개수가 증가함에 따른 collision 증가로 인한 throughput 손해 사이에서 최대한 throughput을 높일 수 있는 방향을 찾도록 channel assignment logic을 설계한다.&lt;/p&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="paper" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">based paper</summary></entry><entry><title type="html">A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs</title><link href="/mye785c83.github.io/posts/10.1155_2019_2149606/" rel="alternate" type="text/html" title="A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/10.1155_2019_2149606</id><content type="html" xml:base="/mye785c83.github.io/posts/10.1155_2019_2149606/">&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;density 증가로 인해&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DCF의 unfair share of bandwidth among nodes issue&lt;/li&gt;
  &lt;li&gt;CST 값이 너무 크면 aggressive trasmission으로 인해 hidden terminals가 증가하고 CST 값이 너무 작으면 conservative transmission으로 인해 exposed terminals가 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposed-scheme&quot;&gt;Proposed Scheme&lt;/h2&gt;

&lt;h3 id=&quot;assumptions&quot;&gt;Assumptions&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;All channels are orthogonal.&lt;/li&gt;
  &lt;li&gt;APs can simultaneously access all channels.&lt;/li&gt;
  &lt;li&gt;The network interface is capable of splitting a channel into multiple narrow channels&lt;/li&gt;
  &lt;li&gt;When a channel is split, the network interface can simultaneously accesses the narrow channels.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;main-idea&quot;&gt;Main Idea&lt;/h3&gt;
&lt;p&gt;associated AP와 &lt;strong&gt;“distance”&lt;/strong&gt;가 비슷한 node를 grouping &amp;amp; assigning &lt;span style=&quot;color:red&quot;&gt;same&lt;/span&gt; channel&lt;/p&gt;

&lt;p class=&quot;comment-box&quot;&gt;👉 CST가 같은 node들의 distance 차이를 최소화해 hidden terminal을 줄이면서도 distance가 가까운 node들은 좀 더 aggressive한 transmission을 통해 throughput을 높일 수 있도록&lt;/p&gt;

&lt;p class=&quot;comment-box&quot;&gt;👉 여기서 distance는 AP와 node 사이의 물리적 거리가 아니라 &lt;span class=&quot;warning text-highlight&quot;&gt;received signal strength&lt;/span&gt; 를 기반으로 측정한 distance이다&lt;/p&gt;

&lt;h4 id=&quot;channel-assignment&quot;&gt;Channel Assignment&lt;/h4&gt;
&lt;p&gt;$C$ orthogonal channels, $N$ high traffic node, $M$ low traffic node가 있다고 할 때&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$N$ 개의 high traffic demand node $n_{i,\ (i=0, … , N-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
 $$
 \cases{max(RSSI(n_i), i=0, … , N-1)=RSSI(n_0)\cr
 min(RSSI(n_i), i=0, … , N-1)=RSSI(n_{N-1})}
 $$&lt;/li&gt;
  &lt;li&gt;high traffic demand node를 distance가 작은 순서대로 $C$등분하여 channel index $0$부터 $(C-1)$까지 할당&lt;/li&gt;
  &lt;li&gt;$M$ 개의 low traffic demand node $m_{i,\ (i=0, … ,M-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
 $$
 \cases{max(RSSI(m_i), i=0, … , N-1)=RSSI(m_0)\cr
 min(RSSI(m_i), i=0, … , M-1)=RSSI(m_{M-1})}
 $$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번에서 각 channel에는 먼저 $K(\lceil{N\over C}\rceil)$개의 high traffic node가 할당되며 channel $ch_i$에 할당된 node ($n_{k,\ (i\times k \leq k \leq (i+1) \times k-1)}$)의 $RSSI$ 최솟값을 $r_i$ 라 하자. ($r_i=RSSI(n_{(i+1) \times k-1})$)
$$
CH(n_i) = ch_{\lfloor {i \over K} \rfloor}
$$&lt;/p&gt;

&lt;p&gt;3번에서 indexing한 low demand node들을 channel에 할당하는 방법은 아래와 같다.
$$
CH(m_i) = \cases{
    ch_0,\qquad \text{if }RSSI(m_i) \geq r_0 \cr
    ch_k, \qquad \text{if }r_{k-1}&amp;gt;RSSI(m_i)\geq r_k \cr
    ch_{C-1}, \qquad \text{if }r_{C-2} &amp;gt; RSSI(m_i)&lt;br /&gt;
}
$$&lt;/p&gt;

&lt;p&gt;즉, $ch_{C-1}$에 할당된 node들을 제외하고 해당 채널에 할당된 node들의 $RSSI$는 $r_i$보다 항상 크거나 같아야 한다.&lt;/p&gt;

&lt;p&gt;아래 표는 $C=3, N=10, M=5$ 일 때 $N$개의 node와 $M$개의 node의 $RSSI$에 따라 할당되는 채널을 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;먼저 high demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다. ($K=\lceil{10 \over 3}\rceil=4$)&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{node}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2.0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.96$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_4$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_5$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.5$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.87$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_7$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.56$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_8$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.54$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_9$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 표에 따른 각 채널의 최소 $RSSI$ 는 아래 표와 같다.&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$r_i$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI(node)$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.96$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_3)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.56$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_7)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_9)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 $r_i$ 값을 바탕으로 작성한 low demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다.&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{node}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.12$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.71$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.33$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.43$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_4$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결과적으로 각 채널에 할당된 node($N+M$)들은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;comment-box&quot;&gt;
👉 $RSSI$ 값이 클수록 distance는 작다.
&lt;/div&gt;

&lt;table class=&quot;math-table&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;$\text{channel}$&lt;/th&gt;
    &lt;th&gt;$\text{node}$ ($\text{RSSI}$ 내림차순)&lt;/th&gt;
    &lt;th&gt;$\text{RSSI}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style=&quot;text-align: center;&quot;&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;5&quot;&gt;$ch_0$&lt;/td&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_0$&lt;/td&gt;
    &lt;td&gt;$3.6$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_0$&lt;/td&gt;
    &lt;td&gt;$3.12$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_1$&lt;/td&gt;
    &lt;td&gt;$3.0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_2$&lt;/td&gt;
    &lt;td&gt;$2.0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_3$&lt;/td&gt;
    &lt;td&gt;$1.96$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;6&quot;&gt;$ch_1$&lt;/td&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_1$&lt;/td&gt;
    &lt;td&gt;$1.71$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_4$&lt;/td&gt;
    &lt;td&gt;$1.6$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_5$&lt;/td&gt;
    &lt;td&gt;$1.5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_2$&lt;/td&gt;
    &lt;td&gt;$1.33$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_6$&lt;/td&gt;
    &lt;td&gt;$0.87$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_7$&lt;/td&gt;
    &lt;td&gt;$0.56$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;4&quot;&gt;$ch_2$&lt;/td&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_8$&lt;/td&gt;
    &lt;td&gt;$0.54$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_3$&lt;/td&gt;
    &lt;td&gt;$0.43$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_9$&lt;/td&gt;
    &lt;td&gt;$0.3$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_4$&lt;/td&gt;
    &lt;td&gt;$0.2$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;carrier-sense-threshold-assignment&quot;&gt;Carrier Sense Threshold Assignment&lt;/h4&gt;
&lt;p&gt;이제 grouping 된 node를 바탕으로 $\text{log-distance path loss model}$을 이용해 각 channel의 carrier sense threshold를 추정한다. 이 논문에선 node가 AP에게 packet을 전송하는 $\text{uplink}$ 방식에서 $\text{CST}$를 추정한다.&lt;/p&gt;

&lt;p&gt;각 group에서 $RSSI$가 가장 작은 node(distance가 가장 먼) node를 기준으로 $\text{CST}$ 를 추정한다. ( $r_i$를 가지는 $\text{high demand node}$ )&lt;/p&gt;

&lt;p&gt;가장 멀리 있는 node( $RSSI$가 가장 작은 node, $\text{node S}$ )가 AP에 packet을 전송했을 때 AP가 이를 성공적으로 수신하기 위해서는 $\text{rx_power}$(packet이 AP에 도착했을 때 전력 크기, recieved power, $P_S$)와 이때 같이 존재하는 noise(잡음, $P_I$)의 $\text{snr_db}=P_S-P_I\text{ [dB]}$ 이 $\text{SNR threshold}$보다 크거나 같아야 한다.
$$
\text{snr_db}=P_S-P_I\text{ [dB]} \geq \text{SNR threshold}
$$&lt;/p&gt;

&lt;p&gt;하지만 DSC(Dynamic Sensitivity Control)에서 packet을 보낼지 말지 결정하는 쪽은 sender이므로 AP에 도달하는 $P_N$이 sender(node)에게는 어떤 크기($P_{CS}$)로 도달하는지 알아야 한다.&lt;/p&gt;

&lt;p&gt;$\text{channel}$에 할당된 node들 중 가장 멀리 있는 node가 가장 보수적으로 transmission에 성공하려면 해당 $\text{channel}$의 $\text{CST}$는 $P_{CS}$보다 작거나 같은 값을 취해야 한다.
$$
CST_i \leq P_{CS} \text{ [dB]}
$$&lt;/p&gt;

&lt;p&gt;$\text{log-distance path loss model}$에서 distance를 바탕으로 path loss$\text{[dB]}$를 구하는 함수를 $D2PL(d)$, path loss$\text{[dB]}$를 바탕으로 distance를 구하는 함수를 $PL2D(p)$라 하자.
$$
D2PL(d) = PL_0 + 10\gamma log_{10}\dfrac{d}{d_0}
$$
$$
PL2D(p) = d_0 \times 10^{(p-PL_0/10\gamma)}
$$&lt;/p&gt;

&lt;p&gt;$PL_0$, $\gamma$, $d_0$ 는 상수이고 모든 node들의 transmit power가 $P_{TX}$로 동일할 때 이를 바탕으로 $\text{channel}$의 $\text{CST}$를 추정하는 방식은 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$P_I$ 설정하기
 $$
 P_I=P_S-SNR_{TH}
 $$
 $P_I$의 크기는 AP가 받는 전력 $P_S$가 성공적으로 decoding 되기 위해서 $P_S-P_I$가 $SNR_{TH}$보다 커져야 한다. $P_I$를 $P_S$가 감당할 수 있는 최대 noise라고 하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$d_I$ 구하기
 $$
 d_I = PL2D(P_{TX}-P_I) = PL2D(P_{TX}-(P_S-SNR_{TH}))
 $$
 $\text{log-distance path loss model}$을 이용해 $P_{CS}$를 구하기 위해서는 $P_I$의 전력이 AP에 감지될 때의 distance($d_I$) 값을 알아야 한다.&lt;/p&gt;

    &lt;p&gt;$P_{CS}$는 $P_I$의 도착 power를 AP의 $\text{rx_power}$로 만드는 임의의 node( $\text{node I}$ )가 packet을 전송했을 때 $\text{node S}$가 감지하는 power이다. 따라서 이를 구하기 위해 $\text{node S}$와 $\text{node I}$의 distance를 ( $d_I+d_S$, $d_S$는 $\text{node S}$와 AP의 distance ) 구해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$P_{CS}$ 구하기
 $$
 P_{CS} = P_{TX} - D2PL(d_I+d_S) + P_M
 $$
 $\text{node I}$가 송신한 power가 $\text{node S}$에 도달할 때의 power인 $P_{CS}[\text{dB}]$는 $d_I+d_S$에 의한 $\text{path loss}$를 transmit power ( $P_{TX}$ )에서 뺀 값이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;simulation-결과&quot;&gt;Simulation 결과&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Varying Node Density&lt;/li&gt;
  &lt;li&gt;Varying Number of Channel&lt;/li&gt;
  &lt;li&gt;Varying AP Density&lt;/li&gt;
  &lt;li&gt;Varying Offset of $P_M$&lt;/li&gt;
  &lt;li&gt;Impact of Path Loss Model Error ( Varying $\gamma$ )&lt;/li&gt;
  &lt;li&gt;Performance of the Propsed Scheme under Dynamic Traffic Conditions&lt;/li&gt;
&lt;/ol&gt;</content><author><name>mye785C83</name></author><category term="ICSL" /><category term="paper" /><category term="network" /><category term="wirelessNetwork" /><summary type="html">Problem density 증가로 인해 DCF의 unfair share of bandwidth among nodes issue CST 값이 너무 크면 aggressive trasmission으로 인해 hidden terminals가 증가하고 CST 값이 너무 작으면 conservative transmission으로 인해 exposed terminals가 증가</summary></entry></feed>