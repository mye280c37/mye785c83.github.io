---
layout: post
title : A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs (작성중)
category: AS818
use_math: true
---

## Problem
density 증가로 인해
* DCF의 unfair share of bandwidth among nodes issue
* CST 값이 너무 크면 aggressive trasmission으로 인해 hidden terminals가 증가하고 CST 값이 너무 작으면 conservative transmissio으로 인해 exposed terminals가 증가

<br><br><br>

## Proposed Scheme          
<br>

### Assumptions
0. All channels are orthogonal.
1. APs can simultaneously access all channels.
2. The network interface is capable of splitting a channel into multiple narrow channels
3. When a channel is split, the network interface can simultaneously accesses the narrow channels.

### Main Idea
associated AP와 **"distance"**가 비슷한 node를 grouping & assigning <span style="color:red">same</span> channel  
<div class="comment-box">
<p>
👉 CST가 같은 node들의 distance 차이를 최소화해 hidden terminal을 줄이면서도 distance가 가까운 node들은 좀 더 aggressive한 transmission을 통해 throughput을 높일 수 있도록</p>
👉 여기서 distance는 AP와 node 사이의 물리적 거리가 아니라 <strong>"received signal strength"</strong> 를 기반으로 측정한 distance이다
</div>
<br>

#### Channel Assignment
$C$ orthogonal channels, $N$ high traffic node, $M$ low traffic node가 있다고 할 때
1. $N$ 개의 high traffic demand node $n_{i,\ (i=0, ... , N-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
    \$$
    \cases{max(RSSI(n_i), i=0, ... , N-1)=RSSI(n_0)\cr
    min(RSSI(n_i), i=0, ... , N-1)=RSSI(n_{N-1})}
    \$$
2. high traffic demand node를 distance가 작은 순서대로 $C$등분하여 channel index $0$부터 $(C-1)$까지 할당
3. $M$ 개의 low traffic demand node $m_{i,\ (i=0, ... ,M-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
    \$$
    \cases{max(RSSI(m_i), i=0, ... , N-1)=RSSI(m_0)\cr
    min(RSSI(m_i), i=0, ... , M-1)=RSSI(m_{M-1})}
    \$$
 
2번에서 각 channel에는 먼저 $K(\lceil{N\over C}\rceil)$개의 high traffic node가 할당되며 channel $ch_i$에 할당된 node ($n_{k,\ (i\times k \leq k \leq (i+1) \times k-1)}$)의 $RSSI$ 최솟값을 $r_i$ 라 하자. ($r_i=RSSI(n_{(i+1) \times k-1})$)
\$$
CH(n_i) = ch_{\lfloor {i \over K} \rfloor}
\$$

3번에서 indexing한 low demand node들을 channel에 할당하는 방법은 아래와 같다.
\$$
CH(m_i) = \cases{
    ch_0,\qquad \text{if }RSSI(m_i) \geq r_0 \cr
    ch_k, \qquad \text{if }r_{k-1}>RSSI(m_i)\geq r_k \cr
    ch_{C-1}, \qquad \text{if }r_{C-2} > RSSI(m_i)  
}
\$$

즉, $ch_{C-1}$에 할당된 node들을 제외하고 해당 채널에 할당된 node들의 $RSSI$는 $r_i$보다 항상 크거나 같아야 한다.

아래 표는 $C=3, N=10, M=5$ 일 때 $N$개의 node와 $M$개의 node의 $RSSI$에 따라 할당되는 채널을 나타낸 것이다.

먼저 high demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다. ($K=\lceil{10 \over 3}\rceil=4$)


$\text{node}$ | $RSSI$ | $\text{channel}$ 
| :---: | :---: | :---: |  
$n_0$ | $3.6$ | $0$ 
$n_1$ | $3.0$ | $0$ 
$n_2$ | $2.0$ | $0$ 
$n_3$ | $1.96$ | $0$ 
$n_4$ | $1.6$ | $1$ 
$n_5$ | $1.5$ | $1$ 
$n_6$ | $0.87$ | $1$ 
$n_7$ | $0.56$ | $1$ 
$n_8$ | $0.54$ | $2$ 
$n_9$ | $0.3$ | $2$ 
{:.math-table} 

위의 표에 따른 각 채널의 최소 $RSSI$ 는 아래 표와 같다.

$\text{channel}$ | $r_i$ | $RSSI(node)$ 
| :---: | :---: | :---: |  
$ch_0$ | $1.96$ | $RSSI(n_3)$ 
$ch_1$ | $0.56$ | $RSSI(n_7)$ 
$ch_2$ | $0.3$ | $RSSI(n_9)$ 
{:.math-table} 

위의 $r_i$ 값을 바탕으로 작성한 low demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다.

$\text{node}$ | $RSSI$ | $\text{channel}$ 
| :---: | :---: | :---: |  
$m_0$ | $3.12$ | $0$ 
$m_1$ | $1.71$ | $1$ 
$m_2$ | $1.33$ | $1$ 
$m_3$ | $0.43$ | $2$ 
$m_4$ | $0.2$ | $2$
{:.math-table} 

결과적으로 각 채널에 할당된 node($N+M$)들은 아래와 같다.
<div class="comment-box">
👉 $RSSI$ 값이 클수록 distance는 작다.
</div>

<table class="math-table">
<thead>
<tr>
    <th>$\text{channel}$</th>
    <th>$\text{node}$ ($\text{RSSI}$ 내림차순)</th>
    <th>$\text{RSSI}$</th>
</tr>
</thead>
<tbody style="text-align: center;">
<tr>
    <td rowspan="5">$ch_0$</td>
    <td style="color: red;">$n_0$</td>
    <td>$3.6$</td>
</tr>
<tr>
    <td style="color: blue;">$m_0$</td>
    <td>$3.12$</td>
</tr>
<tr>
    <td style="color: red;">$n_1$</td>
    <td>$3.0$</td>
</tr>
<tr>
    <td style="color: red;">$n_2$</td>
    <td>$2.0$</td>
</tr>
<tr>
    <td style="color: red;">$n_3$</td>
    <td>$1.96$</td>
</tr>
<tr>
    <td rowspan="6">$ch_1$</td>
    <td style="color: blue;">$m_1$</td>
    <td>$1.71$</td>
</tr>
<tr>
    <td style="color: red;">$n_4$</td>
    <td>$1.6$</td>
</tr>
<tr>
    <td style="color: red;">$n_5$</td>
    <td>$1.5$</td>
</tr>
<tr>
    <td style="color: blue;">$m_2$</td>
    <td>$1.33$</td>
</tr>
<tr>
    <td style="color: red;">$n_6$</td>
    <td>$0.87$</td>
</tr>
<tr>
    <td style="color: red;">$n_7$</td>
    <td>$0.56$</td>
</tr>
<tr>
    <td rowspan="4">$ch_2$</td>
    <td style="color: red;">$n_8$</td>
    <td>$0.54$</td>
</tr>
<tr>
    <td style="color: blue;">$m_3$</td>
    <td>$0.43$</td>
</tr>
<tr>
    <td style="color: red;">$n_9$</td>
    <td>$0.3$</td>
</tr>
<tr>
    <td style="color: blue;">$m_4$</td>
    <td>$0.2$</td>
</tr>
</tbody>
</table>

#### Carrier Sense Threshold Assignment
이제 grouping 된 node를 바탕으로 $\text{path loss model}$을 이용해 각 channel의 carrier sense threshold를 추정한다.

이때 기준은 각 group에서 $RSSI$가 가장 작은 node(distance가 가장 먼) node를 기준으로 $\text{CST}$ 를 추정한다. ( $r_i$를 가지는 $\text{high demand node}$ )