<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/mye785c83.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="/mye785c83.github.io/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2021-07-02T16:37:34+09:00</updated><id>/mye785c83.github.io/feed.xml</id><title type="html">mye785C83</title><author><name>mye785C83</name></author><entry><title type="html">AWS EC2에서 Express.js 서버 배포 및 MongoDB 설정</title><link href="/mye785c83.github.io/posts/EC2_MEN_deploy/" rel="alternate" type="text/html" title="AWS EC2에서 Express.js 서버 배포 및 MongoDB 설정" /><published>2021-07-02T00:00:00+09:00</published><updated>2021-07-02T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/EC2_MEN_deploy</id><content type="html" xml:base="/mye785c83.github.io/posts/EC2_MEN_deploy/">&lt;h2 id=&quot;ec2-인스턴스-설정&quot;&gt;EC2 인스턴스 설정&lt;/h2&gt;

&lt;h4 id=&quot;ssh-port-변경&quot;&gt;SSH port 변경&lt;/h4&gt;

&lt;p&gt;기본 SSH 포트는 22인데 이를 다른 포트로 변경해주는 것이 좋다.&lt;/p&gt;

&lt;h4 id=&quot;password-authentication-for-ssh&quot;&gt;password authentication for SSH&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo passwd `username`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;EC2의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username=ubuntu&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;sshd_conf-file-업데이트&quot;&gt;sshd_conf file 업데이트&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ssh/sshd_config&lt;/code&gt; 파일을 열어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordAuthentication&lt;/code&gt; 값을 yes로 변경한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /etc/ssh/sshd_config

PasswordAuthentication yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ssh-재시작&quot;&gt;SSH 재시작&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;expressjs-mongodb-환경설정&quot;&gt;Express.js, MongoDB 환경설정&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;node-npm-설치&quot;&gt;node, npm 설치&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install nodejs
sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 npm version이 있다면&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install npm@[version] -g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mongodb-설치&quot;&gt;MongoDB 설치&lt;/h4&gt;
&lt;p&gt;다음 &lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/&quot;&gt;docs&lt;/a&gt;를 따라하면 어렵지 않게 설치후 실행가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl status mongod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 통해 MongoDB가 잘 실행되는 것을 확인했으면 DataBase 보안을 위해 authorization을 추가해야한다.&lt;/p&gt;

&lt;h2 id=&quot;database-설정&quot;&gt;DataBase 설정&lt;/h2&gt;

&lt;h4 id=&quot;admin-database-실행-후-root-관리자-생성&quot;&gt;admin database 실행 후, root 관리자 생성&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; use admin
&amp;gt; db.createUser({ user: '이름', pwd: '비밀번호', roles: ['root']})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mongodconf에서-authorization을-enabled로-설정&quot;&gt;mongod.conf에서 authorization을 enabled로 설정&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mongod.conf

net:
  port: 27017
  bindIp: 0.0.0.0

# ...

security:
  authorization: 'enabled'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;warning&quot;&gt;이때 들여쓰기 2칸 제대로 안했다가 conf error 난…&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;mongod-service-재실행&quot;&gt;mongod service ‘재실행’&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service mongod restart
sudo systemctl status mongod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;서버의-mongo-uri에-해당하는-database-및-user-pwd-생성&quot;&gt;서버의 MONGO URI에 해당하는 database 및 user, pwd 생성&lt;/h4&gt;

&lt;p&gt;&lt;span class=&quot;warning&quot;&gt;MONGO URI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env&lt;/code&gt; 파일에 설정되어 있다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;나의 경우 admin database로 가 server database owner에 대한 role도 root user에 추가해주었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; db.updateUser(&quot;username&quot;, {roles:[{role: 'dbOwner', db: 'database name'}]})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;생성한-user-정보로-server-database-접속해보기&quot;&gt;생성한 user 정보로 server database 접속해보기&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongo --port 27017 -u 사용자계정 -p '비밀번호' --authenticationDatabase '디비이름'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 database 설정까지 완료했으면 이제 Express.js 서버를 가져와 실행해준다. (database를 미리 한 이유는 안하면 서버를 먼저 가져와서 실행해봤자 database 접속 못 할거라)&lt;/p&gt;

&lt;h2 id=&quot;expressjs-실행&quot;&gt;Express.js 실행&lt;/h2&gt;

&lt;h4 id=&quot;packagejson-설치&quot;&gt;package.json 설치&lt;/h4&gt;
&lt;p&gt;github에 존재하는 Express.js repository를 clone 해온 후 해당 폴더로 이동해 package.json에 해당하는 패키지들을 설치한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지 마치고 나면 해당 폴더의 하위에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules/&lt;/code&gt; 폴더가 생성된 것을 확인할 수 있다.
여기까지 마치면 서버를 실행해 서버가 잘 실행되고 데이터베이스에 잘 연결되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;comment-box&quot;&gt;
&lt;div class=&quot;title&quot;&gt;포트 방화벽 해제&lt;/div&gt;  
&lt;div class=&quot;body&quot;&gt;
외부에서 서버의 특정 포트에 접근하려면 해당 포트의 방화벽을 해제해야 한다. &lt;br /&gt;
&lt;span class=&quot;warning text-highlight&quot;&gt;어떤 포트를 왜 열어야 되는지 정확히 모르겠다&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;nginx-설정&quot;&gt;NGINX 설정&lt;/h2&gt;

&lt;h4 id=&quot;nginx-설치&quot;&gt;nginx 설치&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;nginx&quot;&gt;nginx&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;HTTP 프로토콜을 준수하여 HTML, CSS, JavaScript, 이미지와 같은 정적 파일을 웹 브라우저(Chrome, Opera …)에 전송하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;리버스 프록시(Reverse Proxy)로서의 역할
    &lt;ul&gt;
      &lt;li&gt;proxy server는 가상 서버이고 reverse server가 실제 응용프로그램 서버를 의미한다.&lt;/li&gt;
      &lt;li&gt;client가 proxy server로 request를 보내면 proxy server는 reverse server로부터 데이터를 가져오는 역할을 한다.&lt;/li&gt;
      &lt;li&gt;웹 응용 프로그램 서버에 reverse proxy가 필요한 이유는 request에 대한 버퍼링 때문이다. client가 직접 app server에 요청을 보낼 경우, 2개 이상의 요청이 들어올 경우, 처리 중인 request 외에는 응답 대기 상태가 되기 때문에 proxy server를 두어 request를 배분하는 역할을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nginx-configuration-파일-설정&quot;&gt;nginx configuration 파일 설정&lt;/h4&gt;

&lt;p&gt;http/https로 보낸 요청을 실제 서버 port로 pass 해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/nginx/sites-available&lt;/code&gt; 에 존재하는 기존의 default 파일을 삭제 후 http/https로 넘어오는 request를 처리할 server block을 생성한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# default

server {
	listen 443;
	server_name `domain name`; # 여러 개의 도메인을 설정할 경우 space로 구분하면 됨
	location / {
		proxy_pass http://127.0.0.1:`web server port`;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;text-highlight warning&quot;&gt; MongoDB compass로 내 데이터베이스를 좀 더 쉽게 관리하고 싶은데 nginx 설정 후, DATABASE로 접근이 안된다… configuration 설정을 어떻게 해야하는걸까…&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;nginx-실행하기&quot;&gt;nginx 실행하기&lt;/h4&gt;
&lt;p&gt;먼저 configuration file이 제대로 작성되었는지 확인한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nginx -t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;제대로 작성되었다면 nginx를 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl enable nginx
sduo systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pm2&quot;&gt;PM2&lt;/h2&gt;

&lt;div class=&quot;comment-box&quot;&gt;
원래는 구매한 도메인 SSL certificate 완료를 해서 해당 도메인을 서버에 씌우고 web server의 port를 443으로 변경하여 실행하였다. 근데 PM2에서 해당 서버를 실행하면 &lt;span class=&quot;text-highlight warning&quot;&gt;Error: listen EACCES 0.0.0.0:443&lt;/span&gt; 다음과 같은 error가 떠서 서치해본 결과 pm2에서 http, https 포트로의 실행은 불가능했고 따라서 다시 기존처럼 서버 포트를 설정하고 nginx를 통해 http/https 요청이 서버 port로 넘어갈 수 있게 하고 pm2를 실행하였다.
&lt;/div&gt;

&lt;h4 id=&quot;ecosystem-file-생성&quot;&gt;ecosystem file 생성&lt;/h4&gt;

&lt;h4 id=&quot;ecosystem-file-실행&quot;&gt;ecosystem file 실행&lt;/h4&gt;

&lt;h2 id=&quot;cerbot&quot;&gt;cerbot&lt;/h2&gt;
&lt;p&gt;원래는 pm2에서 포트 443을 이용해 https 통신을 할 경우 cerbot을 통해 도메인에 대한 ssl certificate key를 받아 이를 설정하는 것 같은데 key 발급을 위해 http로 도메인에 request를 보내 인증을 진행하는 것 같았다.&lt;/p&gt;

&lt;p&gt;하지만 나의 경우 http로 할 경우 이미 SSL 인증을 받아서 그런지 502 error가 떴고 오히려 443으로 열었을 경우 진행이 잘 되었는데 이렇게 해도 되는지 모르겠으며 왜 되는지도 모르겠다.&lt;/p&gt;</content><author><name>mye785C83</name></author><category term="Web" /><category term="AWS" /><category term="EC2" /><category term="ExpressJS" /><category term="MongoDB" /><category term="NodeJS" /><category term="nginx" /><category term="pm2" /><summary type="html">EC2 인스턴스 설정</summary></entry><entry><title type="html">python을 이용한 간단한 network simulation 구현</title><link href="/mye785c83.github.io/posts/python_simulator/" rel="alternate" type="text/html" title="python을 이용한 간단한 network simulation 구현" /><published>2021-04-28T00:00:00+09:00</published><updated>2021-04-28T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/python_simulator</id><content type="html" xml:base="/mye785c83.github.io/posts/python_simulator/">&lt;h4 id=&quot;variable-setting&quot;&gt;variable setting&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;'''
[input]
----------------------------------------------------------------
NUM_GRID,       grid 개수. NUM_GRID=n에 대해 n*n개의 AP가 생성됨
AREA_SIZE,      한 grid 당 사이즈
NUM_NODES,      mobile node 개수
NUM_CH,         channel 개수
PROTO,          protocol(tramsmission) type 
    0: carriersense
    1: DSC
    2: smart
    3: new carrier
CS,             CST 값 
SEED,           seed 값
END,            simulation end time. END만큼 각 채널이 전송 반복
VERBOSE, 
IDEAL, 
LATEX, 
MARGIN,         cst margin 값 (실제 setting cst = 설정 cst +  margin)
DEPLOY,         mobile node 분포 형태
    0: seed를 이용한 random 분포
    1: AP와 ms 사이의 distance가 특정 범위에 몰리도록 분포
SET_CHANNEL,
    0: 기존의 방식대로
    1: 각 채널이 distance에 따라 같은 개수의 node를 가지도록
    2: 각 채널이 assigned node 개수에 따라 다른 bandwidth를 가지도록
------------------------------------------------------------------
'''&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RunSim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NUM_GRID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_NODES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NODES_PER_CELL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AREA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_CH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PROTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEED&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERBOSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CH_BW_LOSS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LATEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDEAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MARGIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TOKEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEPLOY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SET_CHANNEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# variable setting
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;param_seed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEED&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_GRID&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_aps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param_num_grid&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_nodes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_NODES&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_num_channels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM_CH&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_end_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;END&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_cs_thresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PROTO&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_verbose&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VERBOSE&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_ch_bw_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CH_BW_LOSS&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_export_latex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LATEX&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;param_margin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MARGIN&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;1차&quot;&gt;1차&lt;/h2&gt;

&lt;h3 id=&quot;mobile-node-deployment&quot;&gt;Mobile Node Deployment&lt;/h3&gt;

&lt;h4 id=&quot;biased-deployment&quot;&gt;Biased Deployment&lt;/h4&gt;

&lt;p&gt;AP와 ms 사이의 distance 값이 특정 범위에 몰리도록 mobile node를 분포하는 것&lt;/p&gt;

&lt;p&gt;⇒ high demand node의 발생이 불규칙적이고 예측할 수 없을 때 특정 distance에 demand가 과도하게 발생한다면 논문에서 제시한 방법이 비효율적일 수 있다.&lt;/p&gt;

&lt;div class=&quot;comment-box&quot;&gt;
&lt;strong&gt;WHY?&lt;/strong&gt;&lt;br /&gt;  
&lt;p style=&quot;padding-left: 10px; margin-top: 1rem&quot;&gt;
한 channel에 할당된 node들 사이에 distance차가 목표한 바와 다르게 커질 수 있기 때문
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;setting-channel-and-cst&quot;&gt;Setting channel and CST&lt;/h3&gt;

&lt;h4 id=&quot;type1-기존-base-simulator-logic&quot;&gt;type1. 기존 base simulator logic&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;mobile node index를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_num_channels&lt;/code&gt; 로 나눈 나머지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_cs_thresh&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;param_margin&lt;/code&gt; 으로 모든 채널이 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;type2-distance에-따른-node-grouping&quot;&gt;type2. distance에 따른 node grouping&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;각 channel은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(param_num_nodes / param_num_channels)&lt;/code&gt; 만큼의 node를 할당받는다&lt;/li&gt;
      &lt;li&gt;node는 associated AP와의 distance 값이 작은 순서대로 channel index 0부터 차례대로 channel 할당을 받는다
        &lt;ul&gt;
          &lt;li&gt;channel index가 가장 작은 channel( $ch[0]$ )에 할당된 node들의 distance가 가장 작다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;channel에 할당된 node들 중 distance값이 가장 큰 node 기준&lt;/li&gt;
      &lt;li&gt;해당 node가 견딜 수 있는 SNR 크기를 경계로 하여 CST 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;각 node는 associated AP와의 distance가 작은 순서대로 channel index 0부터 차례로 channel 할당을 받는다.&lt;/li&gt;
      &lt;li&gt;channel에 할당된 node의 dist중 가장 작은 dist( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min_dist&lt;/code&gt; )를 기준으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dist_threshold&lt;/code&gt;를 정해 해당 할당 받는 node의 distance가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min_dist + dist_threshold&lt;/code&gt; 보다 클 경우 channel index를 1 늘린다.&lt;/li&gt;
      &lt;li&gt;할당된 node 개수를 비율만큼 channel bandwidth를 할당한다.
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;[simulator 상에서 구현]&lt;/p&gt;

            &lt;p&gt;simulator는 1 time마다 각 channel을 돌면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_vector&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector&lt;/code&gt; 를 구한다.&lt;/p&gt;

            &lt;p&gt;실제로 네트워크 상에서 bandwidth가 커지면 packet 전송 속도가 빨라지기 때문에 1 time당 더 많은 packet이 오갈 수 있다.&lt;/p&gt;

            &lt;p&gt;simulator 상에서는 bandwidth에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector&lt;/code&gt; 에 weight를 주어 속도를 주었다.&lt;/p&gt;

            &lt;p&gt;( » &lt;em&gt;weight: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int(param_num_nodes / param_num_channels)&lt;/code&gt; 와의 비율&lt;/em&gt; )&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;channel에 할당된 node들 중 distance값이 가장 큰 node 기준&lt;/li&gt;
      &lt;li&gt;해당 node가 견딜 수 있는 SNR 크기를 경계로 하여 CST 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stat_rx_packets_ms&lt;/code&gt; 카운트
    &lt;ul&gt;
      &lt;li&gt;매 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch&lt;/code&gt;에 따른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rx_vector * ch_weight[ch]&lt;/code&gt;를 더함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;결과-분석&quot;&gt;결과 분석&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;random하게 분포된 node에서 $\text{type1}$과 $\text{type2}$의 throughput을 비교해보면 $\text{type2}$가 $1.25$ 배 가량 향상된 것을 확인할 수 있었다.
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color: red;&quot;&gt;&lt;em&gt;실제 논문에서는 2배 가량 차이나는데 어떤 차이일지?&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;skewed deployment에서 $\text{type2}$과 $\text{type3}$의 channel 별 throughput과 전체 throughput을 비교하면
    &lt;ul&gt;
      &lt;li&gt;전체 throughput의 경우 거의 비슷하다(약간의 감소)&lt;/li&gt;
      &lt;li&gt;channel별 throughput을 비교해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt; 즉, bandwidth에 따라 설정된 $weight$ 가 크면 커지고 작으면 작아진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;2번-결과에-대한-분석&quot;&gt;&amp;lt;2번 결과에 대한 분석&amp;gt;&lt;/h5&gt;

&lt;p&gt;bandwidth가 클수록 그만큼 그 채널에 할당된 node가 많다는 뜻인데 그 채널에 대해서&lt;span style=&quot;color: red;&quot;&gt;‘&lt;strong&gt;만&lt;/strong&gt;’&lt;/span&gt; $weight$에 의해 많은 throughput이 생성된 것처럼 되고 나머지 다른 채널의 경우 모두 $weight$에 의해 throughput이 낮아지기 때문에 $weight$가 큰 채널에 의해 높은 throughput을 가지게된 node와 $weight$가 낮은 채널에 의해 낮은 throupghput을 가지게된 node간의 throughput 상쇄가 일어나 결론적으로는 합이 비슷해지는 것 같다.&lt;/p&gt;

&lt;h5 id=&quot;2번-결과에-대한-대안&quot;&gt;&amp;lt;2번 결과에 대한 대안&amp;gt;&lt;/h5&gt;

&lt;p&gt;실제로는 bandwidth가 커지면 그만큼 $\text{mbps}$ 가 커져서 한 timeslot에 더 많은 packet이 전송될 수 있다.(수신을 성공하는지와는 관계 없이)
따라서 성공한 packet에 $weight$를 부여하는 대신 timeslot 자체를 $weight$에 따라 조절해 bandwidth가 커 weight가 커지면 timeslot도 $\text{mbps}$가 커진 효과를 내보려 한다.&lt;/p&gt;

&lt;h2 id=&quot;2차&quot;&gt;2차&lt;/h2&gt;

&lt;p&gt;$\text{type1}$, $\text{type2}$에 대한 setting은 유지&lt;/p&gt;

&lt;h4 id=&quot;type3-channel에-할당된-node-개수에-따른-channel-bandwidth-설정-1&quot;&gt;type3. channel에 할당된 node 개수에 따른 channel bandwidth 설정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;channel 할당
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cst 설정
    &lt;ul&gt;
      &lt;li&gt;1차와 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeslot_per_tx&lt;/code&gt; 설정
    &lt;ul&gt;
      &lt;li&gt;기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOTS_PER_TX&lt;/code&gt;로 고정되어 있던 time slot 크기를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIMESLOTS_PER_TX * ch_weight[ch]&lt;/code&gt;로 변경
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;기대 결과&lt;/p&gt;

            &lt;p&gt;늘어난 timeslot만큼 $\text{tx_packet}$ 의 수가 늘어날 것으로 예상&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;실제 결과&lt;/p&gt;

            &lt;p&gt;실제로 $\text{type2}$와 결과를 비교해보면 $\text{tx_packet}$의 수는 줄어들고, $\text{lost_packet}$의 수는 거의 비슷해 결론적으로 $\text{total throughput}$이 줄어드는 것을 확인할 수 있었다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;결과 분석&lt;/p&gt;

            &lt;p&gt;각 채널에 할당된 cst를 확인해보면 미세하게 $\text{type3}$의 cst가 모두 작은 것을 확인할 수 있다.&lt;/p&gt;

            &lt;p&gt;cst 할당 방법은 가장 멀리 있는 node를 기준으로 설정하는 방법을 택했고 skewed deployment 결과 앞쪽 그룹에 node들이 많이 몰려 있기 때문에 각 채널의 가장 멀리 있는 node의 $\text{distance}$ 값이 모두 증가한다. 따라서 cst 값이 작아질 수 밖에 없다.&lt;/p&gt;

            &lt;p&gt;channel 별 throughput을 비교하면 모든 채널의 throughput이 감소하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;가 1 이하인 channel의 경우, timeslot이 감소해서인 것 같다.&lt;/p&gt;

            &lt;p&gt;다만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;가 1보다 큰 경우에도 channel throughput이 감소하는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch_weight&lt;/code&gt;에 의해 늘어난 timeslot의 이득보다 node 개수가 많아지면서 증가한 간섭에 의한 손실이 더 커서인 것으로 예상된다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>mye785C83</name></author><category term="AS818" /><category term="python" /><summary type="html">variable setting ```python ‘’’ [input] —————————————————————- NUM_GRID, grid 개수. NUM_GRID=n에 대해 n*n개의 AP가 생성됨 AREA_SIZE, 한 grid 당 사이즈 NUM_NODES, mobile node 개수 NUM_CH, channel 개수 PROTO, protocol(tramsmission) type 0: carriersense 1: DSC 2: smart 3: new carrier CS, CST 값 SEED, seed 값 END, simulation end time. END만큼 각 채널이 전송 반복 VERBOSE, IDEAL, LATEX, MARGIN, cst margin 값 (실제 setting cst = 설정 cst + margin) DEPLOY, mobile node 분포 형태 0: seed를 이용한 random 분포 1: AP와 ms 사이의 distance가 특정 범위에 몰리도록 분포 SET_CHANNEL, 0: 기존의 방식대로 1: 각 채널이 distance에 따라 같은 개수의 node를 가지도록 2: 각 채널이 assigned node 개수에 따라 다른 bandwidth를 가지도록 —————————————————————— ‘’’</summary></entry><entry><title type="html">A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs</title><link href="/mye785c83.github.io/posts/10.1155_2019_2149606/" rel="alternate" type="text/html" title="A Simple and Practical Scheme Using Multiple Channels for Improving System Spectral Efficiency of Highly Dense Wireless LANs" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>/mye785c83.github.io/posts/10.1155_2019_2149606</id><content type="html" xml:base="/mye785c83.github.io/posts/10.1155_2019_2149606/">&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;density 증가로 인해&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DCF의 unfair share of bandwidth among nodes issue&lt;/li&gt;
  &lt;li&gt;CST 값이 너무 크면 aggressive trasmission으로 인해 hidden terminals가 증가하고 CST 값이 너무 작으면 conservative transmissio으로 인해 exposed terminals가 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proposed-scheme&quot;&gt;Proposed Scheme&lt;/h2&gt;

&lt;h3 id=&quot;assumptions&quot;&gt;Assumptions&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;All channels are orthogonal.&lt;/li&gt;
  &lt;li&gt;APs can simultaneously access all channels.&lt;/li&gt;
  &lt;li&gt;The network interface is capable of splitting a channel into multiple narrow channels&lt;/li&gt;
  &lt;li&gt;When a channel is split, the network interface can simultaneously accesses the narrow channels.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;main-idea&quot;&gt;Main Idea&lt;/h3&gt;
&lt;p&gt;associated AP와 &lt;strong&gt;“distance”&lt;/strong&gt;가 비슷한 node를 grouping &amp;amp; assigning &lt;span style=&quot;color:red&quot;&gt;same&lt;/span&gt; channel&lt;/p&gt;
&lt;div class=&quot;comment-box&quot;&gt;
&lt;p&gt;
👉 CST가 같은 node들의 distance 차이를 최소화해 hidden terminal을 줄이면서도 distance가 가까운 node들은 좀 더 aggressive한 transmission을 통해 throughput을 높일 수 있도록&lt;/p&gt;
👉 여기서 distance는 AP와 node 사이의 물리적 거리가 아니라 &lt;strong&gt;&quot;received signal strength&quot;&lt;/strong&gt; 를 기반으로 측정한 distance이다
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;channel-assignment&quot;&gt;Channel Assignment&lt;/h4&gt;
&lt;p&gt;$C$ orthogonal channels, $N$ high traffic node, $M$ low traffic node가 있다고 할 때&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$N$ 개의 high traffic demand node $n_{i,\ (i=0, … , N-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
 $$
 \cases{max(RSSI(n_i), i=0, … , N-1)=RSSI(n_0)\cr
 min(RSSI(n_i), i=0, … , N-1)=RSSI(n_{N-1})}
 $$&lt;/li&gt;
  &lt;li&gt;high traffic demand node를 distance가 작은 순서대로 $C$등분하여 channel index $0$부터 $(C-1)$까지 할당&lt;/li&gt;
  &lt;li&gt;$M$ 개의 low traffic demand node $m_{i,\ (i=0, … ,M-1)}$ 에 대해 AP와 node 사이의 received signal strength($RSSI$) 내림차순으로 indexing
 $$
 \cases{max(RSSI(m_i), i=0, … , N-1)=RSSI(m_0)\cr
 min(RSSI(m_i), i=0, … , M-1)=RSSI(m_{M-1})}
 $$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번에서 각 channel에는 먼저 $K(\lceil{N\over C}\rceil)$개의 high traffic node가 할당되며 channel $ch_i$에 할당된 node ($n_{k,\ (i\times k \leq k \leq (i+1) \times k-1)}$)의 $RSSI$ 최솟값을 $r_i$ 라 하자. ($r_i=RSSI(n_{(i+1) \times k-1})$)
$$
CH(n_i) = ch_{\lfloor {i \over K} \rfloor}
$$&lt;/p&gt;

&lt;p&gt;3번에서 indexing한 low demand node들을 channel에 할당하는 방법은 아래와 같다.
$$
CH(m_i) = \cases{
    ch_0,\qquad \text{if }RSSI(m_i) \geq r_0 \cr
    ch_k, \qquad \text{if }r_{k-1}&amp;gt;RSSI(m_i)\geq r_k \cr
    ch_{C-1}, \qquad \text{if }r_{C-2} &amp;gt; RSSI(m_i)&lt;br /&gt;
}
$$&lt;/p&gt;

&lt;p&gt;즉, $ch_{C-1}$에 할당된 node들을 제외하고 해당 채널에 할당된 node들의 $RSSI$는 $r_i$보다 항상 크거나 같아야 한다.&lt;/p&gt;

&lt;p&gt;아래 표는 $C=3, N=10, M=5$ 일 때 $N$개의 node와 $M$개의 node의 $RSSI$에 따라 할당되는 채널을 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;먼저 high demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다. ($K=\lceil{10 \over 3}\rceil=4$)&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{node}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2.0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.96$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_4$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_5$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.5$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_6$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.87$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_7$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.56$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_8$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.54$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$n_9$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 표에 따른 각 채널의 최소 $RSSI$ 는 아래 표와 같다.&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$r_i$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI(node)$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.96$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_3)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.56$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_7)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ch_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$RSSI(n_9)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 $r_i$ 값을 바탕으로 작성한 low demand node의 $RSSI$와 $\text{channel}$은 아래 표와 같다.&lt;/p&gt;

&lt;table class=&quot;math-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{node}$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$RSSI$&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$\text{channel}$&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_0$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$3.12$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_1$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.71$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1.33$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$1$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_3$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.43$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$m_4$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$0.2$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$2$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결과적으로 각 채널에 할당된 node($N+M$)들은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;comment-box&quot;&gt;
👉 $RSSI$ 값이 클수록 distance는 작다.
&lt;/div&gt;

&lt;table class=&quot;math-table&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;$\text{channel}$&lt;/th&gt;
    &lt;th&gt;$\text{node}$ ($\text{RSSI}$ 내림차순)&lt;/th&gt;
    &lt;th&gt;$\text{RSSI}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style=&quot;text-align: center;&quot;&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;5&quot;&gt;$ch_0$&lt;/td&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_0$&lt;/td&gt;
    &lt;td&gt;$3.6$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_0$&lt;/td&gt;
    &lt;td&gt;$3.12$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_1$&lt;/td&gt;
    &lt;td&gt;$3.0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_2$&lt;/td&gt;
    &lt;td&gt;$2.0$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_3$&lt;/td&gt;
    &lt;td&gt;$1.96$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;6&quot;&gt;$ch_1$&lt;/td&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_1$&lt;/td&gt;
    &lt;td&gt;$1.71$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_4$&lt;/td&gt;
    &lt;td&gt;$1.6$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_5$&lt;/td&gt;
    &lt;td&gt;$1.5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_2$&lt;/td&gt;
    &lt;td&gt;$1.33$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_6$&lt;/td&gt;
    &lt;td&gt;$0.87$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_7$&lt;/td&gt;
    &lt;td&gt;$0.56$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&quot;4&quot;&gt;$ch_2$&lt;/td&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_8$&lt;/td&gt;
    &lt;td&gt;$0.54$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_3$&lt;/td&gt;
    &lt;td&gt;$0.43$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: red;&quot;&gt;$n_9$&lt;/td&gt;
    &lt;td&gt;$0.3$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td style=&quot;color: blue;&quot;&gt;$m_4$&lt;/td&gt;
    &lt;td&gt;$0.2$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;carrier-sense-threshold-assignment&quot;&gt;Carrier Sense Threshold Assignment&lt;/h4&gt;
&lt;p&gt;이제 grouping 된 node를 바탕으로 $\text{log-distance path loss model}$을 이용해 각 channel의 carrier sense threshold를 추정한다. 이 논문에선 node가 AP에게 packet을 전송하는 $\text{uplink}$ 방식에서 $\text{CST}$를 추정한다.&lt;/p&gt;

&lt;p&gt;각 group에서 $RSSI$가 가장 작은 node(distance가 가장 먼) node를 기준으로 $\text{CST}$ 를 추정한다. ( $r_i$를 가지는 $\text{high demand node}$ )&lt;/p&gt;

&lt;p&gt;가장 멀리 있는 node( $RSSI$가 가장 작은 node, $\text{node S}$ )가 AP에 packet을 전송했을 때 AP가 이를 성공적으로 수신하기 위해서는 $\text{rx_power}$(packet이 AP에 도착했을 때 전력 크기, recieved power, $P_S$)와 이때 같이 존재하는 noise(잡음, $P_I$)의 $\text{snr_db}=P_S-P_I\text{ [dB]}$ 이 $\text{SNR threshold}$보다 크거나 같아야 한다.
$$
\text{snr_db}=P_S-P_I\text{ [dB]} \geq \text{SNR threshold}
$$&lt;/p&gt;

&lt;p&gt;하지만 DSC(Dynamic Sensitivity Control)에서 packet을 보낼지 말지 결정하는 쪽은 sender이므로 AP에 도달하는 $P_N$이 sender(node)에게는 어떤 크기($P_{CS}$)로 도달하는지 알아야 한다.&lt;/p&gt;

&lt;p&gt;$\text{channel}$에 할당된 node들 중 가장 멀리 있는 node가 가장 보수적으로 transmission에 성공하려면 해당 $\text{channel}$의 $\text{CST}$는 $P_{CS}$보다 작거나 같은 값을 취해야 한다.
$$
CST_i \leq P_{CS} \text{ [dB]}
$$&lt;/p&gt;

&lt;p&gt;$\text{log-distance path loss model}$에서 distance를 바탕으로 path loss$\text{[dB]}$를 구하는 함수를 $D2PL(d)$, path loss$\text{[dB]}$를 바탕으로 distance를 구하는 함수를 $PL2D(p)$라 하자.
$$
D2PL(d) = PL_0 + 10\gamma log_{10}\dfrac{d}{d_0}
$$
$$
PL2D(p) = d_0 \times 10^{(p-PL_0/10\gamma)}
$$&lt;/p&gt;

&lt;p&gt;$PL_0$, $\gamma$, $d_0$ 는 상수이고 모든 node들의 transmit power가 $P_{TX}$로 동일할 때 이를 바탕으로 $\text{channel}$의 $\text{CST}$를 추정하는 방식은 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$P_I$ 설정하기
 $$
 P_I=P_S-SNR_{TH}
 $$
 $P_I$의 크기는 AP가 받는 전력 $P_S$가 성공적으로 decoding 되기 위해서 $P_S-P_I$가 $SNR_{TH}$보다 커져야 한다. $P_I$를 $P_S$가 감당할 수 있는 최대 noise라고 하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$d_I$ 구하기
 $$
 d_I = PL2D(P_{TX}-P_I) = PL2D(P_{TX}-(P_S-SNR_{TH}))
 $$
 $\text{log-distance path loss model}$을 이용해 $P_{CS}$를 구하기 위해서는 $P_I$의 전력이 AP에 감지될 때의 distance($d_I$) 값을 알아야 한다.&lt;/p&gt;

    &lt;p&gt;$P_{CS}$는 $P_I$의 도착 power를 AP의 $\text{rx_power}$로 만드는 임의의 node( $\text{node I}$ )가 packet을 전송했을 때 $\text{node S}$가 감지하는 power이다. 따라서 이를 구하기 위해 $\text{node S}$와 $\text{node I}$의 distance를 ( $d_I+d_S$, $d_S$는 $\text{node S}$와 AP의 distance ) 구해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$P_{CS}$ 구하기
 $$
 P_{CS} = P_{TX} - D2PL(d_I+d_S) + P_M
 $$
 $\text{node I}$가 송신한 power가 $\text{node S}$에 도달할 때의 power인 $P_{CS}[\text{dB}]$는 $d_I+d_S$에 의한 $\text{path loss}$를 transmit power ( $P_{TX}$ )에서 뺀 값이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;simulation-결과&quot;&gt;Simulation 결과&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Varying Node Density&lt;/li&gt;
  &lt;li&gt;Varying Number of Channel&lt;/li&gt;
  &lt;li&gt;Varying AP Density&lt;/li&gt;
  &lt;li&gt;Varying Offset of $P_M$&lt;/li&gt;
  &lt;li&gt;Impact of Path Loss Model Error ( Varying $\gamma$ )&lt;/li&gt;
  &lt;li&gt;Performance of the Propsed Scheme under Dynamic Traffic Conditions&lt;/li&gt;
&lt;/ol&gt;</content><author><name>mye785C83</name></author><category term="AS818" /><category term="paper" /><summary type="html">Problem density 증가로 인해 DCF의 unfair share of bandwidth among nodes issue CST 값이 너무 크면 aggressive trasmission으로 인해 hidden terminals가 증가하고 CST 값이 너무 작으면 conservative transmissio으로 인해 exposed terminals가 증가</summary></entry></feed>